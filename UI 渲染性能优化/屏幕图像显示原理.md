# 屏幕图像显示原理

> 关键词：像素、位图/纹理、GPU、合成、OpenGL


## 一、基本概念
### 1. 驱动程序

驱动程序是添加到操作系统中的一小块代码，其中包含有关硬件设备的信息。有了此信息，计算机就可以与设备进行通信。对于装有显卡的计算机来说，没有显卡驱动，就不能识别GPU硬件，不能调用其计算资源。

驱动程序是硬件的一部分，当你安装新硬件时，驱动程序是一项不可或缺的重要元件。凡是安装一个原本不属于你电脑中的硬件设备时，系统就会要求你安装驱动程序，将新的硬件与电脑系统连接起来。**驱动程序扮演沟通的角色，把硬件的功能告诉电脑系统，并且也将系统的指令传达给硬件，让它开始工作。**

参考：   
- [驱动 - 百度百科](https://baike.baidu.com/item/%E9%A9%B1%E5%8A%A8/2765136)
- [显卡、显卡驱动、cuda 之间的关系是什么？](https://www.zhihu.com/question/59184480)

### 2. 显卡

#### 2.1 什么是显卡
显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。显卡作为电脑主机里的一个重要组成部分，是电脑进行数模信号转换的设备，承担输出显示图形的任务。显卡接在电脑主板上，它将电脑的数字信号转换成模拟信号让显示器显示出来，同时显卡还是有图像处理能力，可协助CPU工作，提高整体的运行速度。

#### 2.2 显卡的工作原理

数据（data）一旦离开CPU，必须通过4个步骤，最后才会到达显示屏：

1．从总线（Bus）进入GPU（Graphics Processing Unit，图形处理器）：将CPU送来的数据送到北桥（主桥）再送到GPU（图形处理器）里面进行处理。           
2．从 Video Chipset（显卡芯片组）进入 Video RAM（显存）：将芯片处理完的数据送到显存。           
3．从显存进入Digital Analog Converter （= RAM DAC，随机读写存储数—模转换器）：从显存读取出数据再送到RAM DAC进行数据转换的工作（数字信号转模拟信号）。但是如果是DVI接口类型的显卡，则不需要经过数字信号转模拟信号。而直接输出数字信号。           
4．从DAC进入显示器（Monitor）：将转换完的模拟信号送到显示屏。  
         
显示效能是系统效能的一部分，其效能的高低由以上四步所决定，它与显卡的效能（Video Performance）不太一样，如要严格区分，显卡的效能应该受中间两步所决定，因为这两步的资料传输都是在显卡的内部。第一步是由CPU 进入到显卡里面，最后一步是由显卡直接送资料到显示屏上。   


#### 2.3 显卡的构成

显卡通常由总线接口、PCB板、显示芯片、显存、RAMDAC、VGA BIOS、VGA功能插针、D-sub插座及其他外围组件构成，现在的显卡大多还具有VGA、DVI显示器接口或者HDMI接口及S-Video端子和Display Port接口。      

显示芯片：Video chipset，也叫GPU或VPU，图形处理器或视觉处理器，是显卡的主要处理单元 。 
显存：显存全称显示存储器，亦称帧缓存，它是用来存储显示芯片处理过或者即将读取的渲染数据。如同计算机的内存一样，显存是用来存储图形数据的硬件。

参考：   
- [显卡 - 百度百科](https://baike.baidu.com/item/%E6%98%BE%E5%8D%A1)
- [显卡 - 维基百科](https://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E5%8D%A1)
- [显存 - 维基百科](https://zh.wikipedia.org/wiki/%E6%98%BE%E5%AD%98)

### 3. GPU

#### 3.1 什么是 GPU ？
图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上**图像运算**工作的微处理器。

#### 3.2 GPU 的作用
显卡的处理器称为图形处理器（GPU），它是显卡的“心脏”，与CPU类似，只不过GPU是**专为执行复杂的数学和几何计算而设计的**，这些计算是图形渲染所必需的。某些最快速的GPU集成的晶体管数甚至超过了普通CPU。

如果CPU想画一个二维图形，只需要发个指令给GPU，如“在坐标位置（x, y）处画个长和宽为a×b大小的长方形”，GPU就可以迅速计算出该图形的所有像素，并在显示器上指定位置画出相应的图形，画完后就通知CPU “我画完了”，然后等待CPU发出下一条图形指令。


有了GPU，CPU就从图形处理的任务中解放出来，可以执行其他更多的系统任务，这样可以大大提高计算机的整体性能。

参考：     
- [图形处理器 - 百度百科](https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8/8694767?fromtitle=gpu&fromid=105524)

#### 3.3 GPU 和 CPU 的区别？


参考：      
- [CPU 和 GPU 的区别是什么？](https://www.zhihu.com/question/19903344)

#### 3.4 GPU 的工作原理


参考：      
- [CPU 和 GPU 的区别是什么？](https://www.zhihu.com/question/19903344)

#### 3.5 GPU 和显卡的关系

GPU 是显卡的主要处理单元。GPU是显示卡的“大脑”，GPU决定了该显卡的档次和大部分性能，同时GPU也是2D显示卡和3D显示卡的区别依据。

GPU 使显卡减少了对中央处理器的依赖，并分担了部分原本是由中央处理器所担当的工作，尤其是在进行三维绘图运算时，功效更加明显。

参考：     
- [GPU 和显卡是什么关系？](https://www.zhihu.com/question/28422454)
- [图形处理器 - 维基百科](https://zh.wikipedia.org/wiki/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8)


## 二、图像显示原理


### 1. View 是如何显示到屏幕上的 


#### 1.1 图像显示流程

图像显示的最基本的单元——像素。

![](https://www.objccn.io/images/issues/issue-3/pixels-software-stack.png)

屏幕图像的显示依赖于 GPU 合成的位图/纹理，软件层通过 GPU Driver 跟 GPU 硬件打交道。OpenGL(Open Graphics Library) 提供了 2D 和 3D 图形渲染的 API，自从 OpenGL 的出现，程序员不再需要为每个GPU重写他们的应用了。基于 OpenGL，Apple 通过 Core Animation、Core Graphics 和 Core Image 等框架实现了更高层次的图像绘制功能。

![](https://www.objccn.io/images/issues/issue-3/pixels%2C%20hardware.png)

从 CPU 到 GPU 要面临的两个挑战：

- 为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。
- GPU 需要将每一个 frame 的纹理(位图)合成在一起(60次/秒)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。


#### 1.2 Core Animation：UIView VS CALayer



### 2. 合成（Compositing）
在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。

让我们先暂时忽略一些复杂的细节，并且假定屏幕上一切皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。

在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成大概的意思。

### 3. 混合（Blending）：透明 VS 不透明
- 当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。

- CALayer 有一个叫做 opaque 的属性了。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。
 
- 如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES（UIView 的 backgroundColor 同理）。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。也就是说，如果你用 UIImageView 来显示一张有 alpha 通道的图片，也会导致 blending，即使你设置了 `imageView.backgroundColor = YES;`。

### 4. 像素对齐（Pixel Alignment）


在 iOS 中，有一个概念叫做像素对齐，如果像素不对齐，那么在GPU渲染时，需要进行插值计算，这个插值计算的过程会有性能损耗。

主要有两个原因可能会造成不对齐：   

- 第一个便是缩放，当一个纹理放大缩小的时候，纹理的像素便不会和屏幕的像素排列对齐。
  - 比如在 iPhone 6 上，一张 400 * 500 像素的图片在一个 200 * 252 pt （物理像素为 400 * 504 pixel）或者 100 * 125 pt（物理像素为 200 * 250 pixel）的 UIImageView 中展示时，就会出现像素不对齐的情况。
- 另一个原因便是当纹理的起点不在一个像素的边界上。
  - 比如设置一个 UILabel 的 frame 为 `CGRectMake(100.03, 494.0, 197.0, 76.0)` 时，就会出现像素不对齐的情况，因为 x 坐标乘以 2 或者 3 之后都会有小数部分。


在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。

在 iPhone 模拟器和 Instruments 上，有一个 color misaligned images 选项可以把像素不对齐的部分显示出来。

延伸阅读：

- [iOS优化：解决iOS中像素不对齐问题](https://www.jianshu.com/p/432fea0232b8)
- [iOS开发之图片分辨率与像素对齐](https://www.cnblogs.com/huahuahu/p/iOS-kai-fa-zhi-tu-pian-fen-bian-lu-yu-xiang-su-dui.html)

### 5. CALayer 的 Mask

Mask 属性本身也是一个 CALayer。不同于那些绘制在父图层中的 sublayer，mask 图层定义了父图层的部分可见区域。

mask图层的Color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。也就是说，父图层中只有在 mask 范围内的(即图层中的部分)内容才会被渲染出来。

参考：

- [Mask - iOS Core Animation Advanced Techniques](https://zsisme.gitbooks.io/ios-/content/chapter4/layer-masking.html)


### 4. 光栅化

光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。

Instrument中，第二个调试选项是“Color Hits Green and Misses Red”，它表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好。

当设置 `view.layer.shouldRasterize = YES` 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。需要注意的是，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。因此光栅化仅适用于经常使用的、较复杂的、静态的效果。

### 5. 离屏渲染（Offscreen Rendering）

#### 5.1 什么是离屏渲染

离屏渲染一般是指 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行合成、渲染操作，然后再渲染到屏幕上。离屏渲染可以被 Core Animation 或者系统自动触发。

当图像合成计算非常复杂时，你也可以手动强制使用离屏渲染——将合成好的图层或者纹理缓存起来，然后当再次需要显示这些图层时，就可以读取这些缓存了。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。

但是，这其实也需要权衡一下。第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。另外，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。


#### 5.2 离屏渲染所带来的问题
相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：

（1）创建新缓冲区
要想进行离屏渲染，首先要创建一个新的缓冲区。

（2）上下文切换
离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。

#### 5.3 哪些情况可能会导致 Offscreen Render 呢？

- `layer.shouldRasterize = YES;`
- 设置 mask 或者阴影
  - masksToBounds（但是最新的试验中却没有产生离屏渲染，iOS 11，Xcode 9.3）
  - masks（遮罩）
  - shadows（阴影）
  - edge antialiasing（抗锯齿）
  - group opacity（不透明）
- 重写 `-drawRect` 方法
  - 这是一种特殊的“离屏渲染”方式，如果我们重写了drawRect方法，并且使用任何 Core Graphics 的技术进行了绘制操作，就涉及到了 **CPU 渲染**。整个渲染过程由 CPU 在App内同步地完成，渲染得到的 bitmap 最后再交给 GPU 去显示。

> 设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合 `layer.masksToBounds = YES` 使用，正是因为操作了 mask 才导致的离屏渲染。

#### 5.4 如何避免离屏渲染

- 设置阴影：通过设置 layer 的 shadowPath 属性来设置阴影的路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。
- 设置圆角（分两种情况）：
  - 设置 UIImageView 的圆角：先通过 Core Graphics 结合 UIBezierPath 将原图片（UIImage）裁剪成圆角形式的图片，然后再赋值给 UIImageView 的 image 属性。这个过程其实可以异步执行并且缓存起来，具体实现可以参考 [YYKit](https://github.com/ibireme/YYKit/blob/master/Demo/YYKitDemo/WBStatusCell.m#L757) 中的 demo。
  - 设置其他非图片展示类型的 UIView 的圆角：创建一个圆角矩形的 CAShapeLayer，然后再添加到 view.layer 的最底层，具体代码见 [这里](https://zsisme.gitbooks.io/ios-/content/chapter15/offscreen-rendering.html)。或者用 Core Graphics 的 API 绘制一个圆角矩形图片，然后再基于这个图片创建一个 UIImageView，最后再添加到 view 层级的最底层。

参考：

- [iOS 高效添加圆角效果实战讲解](https://bestswifter.com/efficient-rounded-corner/)

#### 5.5 当前屏幕渲染 VS 离屏渲染 VS CPU 渲染

- 当屏渲染永远是最好的选择
  - 鉴于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，我们要尽量使用当前屏幕渲染。
- 离屏渲染 VS CPU 渲染
  - 由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用CPU渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。而且 CPU 上还可以使用异步绘制。

#### 5.6 调试检测
Instrument 的 Core Animation 工具有一个叫做 Color Offscreen-Rendered Yellow 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。



## 参考
- [计算机图形渲染的流程](https://bbs.feng.com/read-htm-tid-6880069.html)
- [iOS图形渲染分析](https://www.jianshu.com/p/77d0cb17cfad)
- [绘制像素到屏幕上 - objc.io](https://www.objccn.io/issue-3-1/)
- [UIKit性能调优实战讲解](https://bestswifter.com/uikitxing-neng-diao-you-shi-zhan-jiang-jie/)
- [深刻理解移动端优化之离屏渲染](https://www.jianshu.com/p/d74398c50fe1)
- [使用 Instruments 做 iOS 程序性能调试](http://www.samirchen.com/use-instruments/)